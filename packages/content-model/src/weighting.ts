/**
 * Narrative Block Weighting System for LLM Ranking
 * 
 * This module provides a comprehensive scoring system for ranking narrative blocks
 * by importance, recency, relevance, and other factors. The weights are designed
 * to help LLMs prioritize which blocks to include in final outputs (abstracts, summaries).
 * 
 * Weighting Strategy:
 * 1. Base Weight: template type importance (e.g., identity-mode=3, stage-context=3)
 * 2. Temporal Weight: recency factor (recent blocks score higher)
 * 3. Relevance Weight: match to active mask/epoch/stage filters
 * 4. Coherence Weight: semantic alignment with other blocks in the narrative
 * 5. Confidence Weight: how certain we are about the block's accuracy/completeness
 */

import type { NarrativeBlock, Mask, Epoch, Stage } from \"@in-midst-my-life/schema\";\n\n/**\n * Configuration for weighting narrative blocks.\n * Allows customization of how different factors influence final scores.\n */\nexport interface WeightingConfig {\n  /** Relative importance of base template weight (0-1, default: 0.25) */\n  baseWeightFactor?: number;\n  /** Relative importance of temporal recency (0-1, default: 0.15) */\n  recencyFactor?: number;\n  /** Relative importance of mask/context relevance (0-1, default: 0.35) */\n  relevanceFactor?: number;\n  /** Relative importance of coherence with other blocks (0-1, default: 0.15) */\n  coherenceFactor?: number;\n  /** Relative importance of confidence/accuracy (0-1, default: 0.10) */\n  confidenceFactor?: number;\n  /** How far back (in days) to consider blocks \"recent\" (default: 365) */\n  recencyWindowDays?: number;\n  /** Boost factor for blocks tagged with specific keywords (default: 1.5x) */\n  keywordBoostFactor?: number;\n  /** Keywords that receive relevance boosts */\n  priorityKeywords?: string[];\n}\n\n/**\n * Detailed scoring breakdown for a narrative block.\n * Useful for debugging and understanding why blocks ranked as they did.\n */\nexport interface BlockScore {\n  blockId: string;\n  totalScore: number;\n  breakdown: {\n    baseWeight: number;\n    recencyScore: number;\n    relevanceScore: number;\n    coherenceScore: number;\n    confidenceScore: number;\n  };\n  factors: {\n    isRecent: boolean;\n    hasRelevantTags: boolean;\n    hasKeywordBoost: boolean;\n    tagCount: number;\n  };\n}\n\n/**\n * Calculate how recent a block is (1.0 = today, 0.0 = beyond window).\n * Assumes blocks have implicit creation or update timestamps.\n */\nfunction calculateRecencyScore(\n  createdAt: string | undefined,\n  windowDays: number = 365\n): number {\n  if (!createdAt) return 0.5; // Unknown age gets mid-range score\n  \n  try {\n    const parsed = new Date(createdAt).getTime();\n    if (!Number.isFinite(parsed)) return 0.5;\n    \n    const now = Date.now();\n    const ageMs = now - parsed;\n    const ageDays = ageMs / (1000 * 60 * 60 * 24);\n    \n    if (ageDays < 0) return 1.0; // Future-dated (edge case)\n    if (ageDays > windowDays) return 0.0;\n    \n    // Linear decay: recent blocks score 1.0, old blocks score 0.0\n    return 1.0 - (ageDays / windowDays);\n  } catch {\n    return 0.5;\n  }\n}\n\n/**\n * Calculate relevance score based on tag matching and mask affinity.\n */\nfunction calculateRelevanceScore(\n  block: NarrativeBlock,\n  activeMask: Mask | undefined,\n  activeContexts: Set<string>,\n  activeTags: Set<string>,\n  priorityKeywords: Set<string>\n): number {\n  const blockTags = new Set((block.tags ?? []).map((t) => t.toLowerCase()));\n  \n  // Direct tag matching\n  let tagMatches = 0;\n  let tagScore = 0;\n  \n  for (const tag of blockTags) {\n    if (activeTags.has(tag)) {\n      tagMatches += 1;\n      tagScore += 2; // Exact match\n    } else if (priorityKeywords.has(tag)) {\n      tagScore += 1.5; // Keyword boost\n    }\n  }\n  \n  // Mask affinity\n  let maskScore = 0;\n  if (activeMask) {\n    // Check if block's tags align with mask's include_tags\n    const maskIncludes = new Set(\n      activeMask.filters.include_tags.map((t) => t.toLowerCase())\n    );\n    const maskExcludes = new Set(\n      activeMask.filters.exclude_tags.map((t) => t.toLowerCase())\n    );\n    \n    // Penalty for excluded tags\n    if ([...blockTags].some((t) => maskExcludes.has(t))) {\n      return 0; // Don't include blocks that violate mask exclusions\n    }\n    \n    // Bonus for included tags\n    const includeMatches = [...blockTags].filter((t) => maskIncludes.has(t)).length;\n    maskScore = includeMatches * 2;\n  }\n  \n  // Normalize: max score roughly 10 (5 tags * 2 points each + mask bonus)\n  const normalizedScore = Math.min(10, tagScore + maskScore);\n  return normalizedScore / 10;\n}\n\n/**\n * Calculate semantic coherence with other blocks in the narrative.\n * This is a simplified heuristic; in production, use embeddings or LLM-based scoring.\n */\nfunction calculateCoherenceScore(\n  block: NarrativeBlock,\n  allBlocks: NarrativeBlock[],\n  contextArc: string[] // e.g., [\"mask-a\", \"stage-b\", \"epoch-c\"]\n): number {\n  if (allBlocks.length === 0) return 0.5;\n  \n  // Blocks with template IDs that follow a logical narrative order score higher\n  const narrativeSequence = [\n    \"identity-mode\",\n    \"stage-context\",\n    \"sequence\",\n    \"stage-arc\",\n    \"epoch-arc\",\n    \"evidence\",\n    \"next-move\"\n  ];\n  \n  const templateId = block.templateId ?? \"unknown\";\n  const templateIndex = narrativeSequence.indexOf(templateId);\n  \n  // Blocks that are in the expected sequence score higher\n  if (templateIndex >= 0) {\n    return (templateIndex + 1) / narrativeSequence.length;\n  }\n  \n  // Count overlapping tags with adjacent blocks as a coherence proxy\n  const blockTagSet = new Set((block.tags ?? []).map((t) => t.toLowerCase()));\n  let coherenceMatches = 0;\n  let comparisons = 0;\n  \n  for (const otherBlock of allBlocks) {\n    if (otherBlock === block) continue;\n    comparisons += 1;\n    \n    const otherTags = new Set((otherBlock.tags ?? []).map((t) => t.toLowerCase()));\n    const intersection = [...blockTagSet].filter((t) => otherTags.has(t)).length;\n    if (intersection > 0) coherenceMatches += 1;\n  }\n  \n  if (comparisons === 0) return 0.5;\n  return coherenceMatches / comparisons;\n}\n\n/**\n * Calculate confidence in a block's accuracy.\n * This is a placeholder; in production, track verification status, sources, etc.\n */\nfunction calculateConfidenceScore(\n  block: NarrativeBlock,\n  _mask: Mask | undefined\n): number {\n  // Blocks with template IDs from official templates score higher\n  const officialTemplates = [\n    \"identity-mode\",\n    \"stage-context\",\n    \"sequence\",\n    \"stage-arc\",\n    \"epoch-arc\",\n    \"setting-arc\",\n    \"next-move\"\n  ];\n  \n  if (block.templateId && officialTemplates.includes(block.templateId)) {\n    return 0.95; // High confidence in official templates\n  }\n  \n  // Blocks with explicit tags and context score higher\n  const tagCount = (block.tags ?? []).length;\n  if (tagCount >= 2) return 0.8;\n  if (tagCount === 1) return 0.6;\n  \n  // Untagged blocks default to moderate confidence\n  return 0.5;\n}\n\n/**\n * Score a single narrative block against the current narrative context.\n * \n * @param block The narrative block to score\n * @param context Narrative context (mask, epochs, stages, etc.)\n * @param allBlocks All blocks in the narrative (for coherence scoring)\n * @param config Weighting configuration\n * @returns Detailed score breakdown\n * \n * @example\n * const score = scoreNarrativeBlock(block, {\n *   mask: analyticalMask,\n *   activeContexts: new Set([\"technical\", \"analysis\"]),\n *   activeTags: new Set([\"architecture\", \"metrics\"])\n * }, allBlocks);\n * \n * console.log(`Block: ${score.totalScore.toFixed(2)}`); // 0.85\n * console.log(score.breakdown); // { baseWeight: 0.3, recencyScore: 0.75, ... }\n */\nexport function scoreNarrativeBlock(\n  block: NarrativeBlock,\n  context: {\n    mask?: Mask;\n    activeContexts?: Set<string>;\n    activeTags?: Set<string>;\n    activeEpoch?: Epoch;\n    activeStage?: Stage;\n    createdAt?: string;\n    contextArc?: string[];\n  },\n  allBlocks: NarrativeBlock[] = [],\n  config: WeightingConfig = {}\n): BlockScore {\n  // Normalize configuration with defaults\n  const baseWeightFactor = config.baseWeightFactor ?? 0.25;\n  const recencyFactor = config.recencyFactor ?? 0.15;\n  const relevanceFactor = config.relevanceFactor ?? 0.35;\n  const coherenceFactor = config.coherenceFactor ?? 0.15;\n  const confidenceFactor = config.confidenceFactor ?? 0.10;\n  const recencyWindowDays = config.recencyWindowDays ?? 365;\n  const priorityKeywords = new Set(\n    (config.priorityKeywords ?? []).map((k) => k.toLowerCase())\n  );\n  \n  // Calculate individual scores (0-1 range)\n  const baseWeight = block.weight ? Math.min(1, block.weight / 5) : 0.5;\n  const recencyScore = calculateRecencyScore(context.createdAt, recencyWindowDays);\n  const relevanceScore = calculateRelevanceScore(\n    block,\n    context.mask,\n    context.activeContexts ?? new Set(),\n    context.activeTags ?? new Set(),\n    priorityKeywords\n  );\n  const coherenceScore = calculateCoherenceScore(\n    block,\n    allBlocks,\n    context.contextArc ?? []\n  );\n  const confidenceScore = calculateConfidenceScore(block, context.mask);\n  \n  // Weighted combination (factors should sum to ~1.0)\n  const totalScore =\n    baseWeight * baseWeightFactor +\n    recencyScore * recencyFactor +\n    relevanceScore * relevanceFactor +\n    coherenceScore * coherenceFactor +\n    confidenceScore * confidenceFactor;\n  \n  return {\n    blockId: block.title,\n    totalScore: Math.min(1, totalScore),\n    breakdown: {\n      baseWeight: baseWeight * baseWeightFactor,\n      recencyScore: recencyScore * recencyFactor,\n      relevanceScore: relevanceScore * relevanceFactor,\n      coherenceScore: coherenceScore * coherenceFactor,\n      confidenceScore: confidenceScore * confidenceFactor\n    },\n    factors: {\n      isRecent: recencyScore > 0.7,\n      hasRelevantTags: relevanceScore > 0.5,\n      hasKeywordBoost: (block.tags ?? []).some((t) => priorityKeywords.has(t.toLowerCase())),\n      tagCount: (block.tags ?? []).length\n    }\n  };\n}\n\n/**\n * Score and rank all narrative blocks in a set.\n * Useful for generating summaries or prioritizing which blocks to include in outputs.\n * \n * @param blocks Array of narrative blocks to score\n * @param context Narrative context\n * @param config Weighting configuration\n * @returns Blocks sorted by score (highest first), with score metadata\n * \n * @example\n * const ranked = rankNarrativeBlocks(blocks, {\n *   mask: myMask,\n *   activeContexts: new Set([\"technical\", \"strategic\"])\n * });\n * \n * // Take top 5 blocks for a summary\n * const summary = ranked.slice(0, 5).map(item => item.block);\n */\nexport function rankNarrativeBlocks(\n  blocks: NarrativeBlock[],\n  context: Parameters<typeof scoreNarrativeBlock>[1],\n  config: WeightingConfig = {}\n): Array<{ block: NarrativeBlock; score: BlockScore }> {\n  const scores = blocks.map((block) =>\n    scoreNarrativeBlock(block, context, blocks, config)\n  );\n  \n  const ranked = blocks\n    .map((block, idx) => ({ block, score: scores[idx] }))\n    .sort((a, b) => b.score.totalScore - a.score.totalScore);\n  \n  return ranked;\n}\n\n/**\n * Filter narrative blocks to top N most important ones.\n * Useful for generating abstracts or summaries.\n * \n * @param blocks All blocks in the narrative\n * @param topN How many blocks to select (default: 5)\n * @param context Narrative context\n * @param config Weighting configuration\n * @returns Top N blocks, sorted by importance\n * \n * @example\n * const abstract = selectTopBlocks(blocks, 3, context);\n * const summary = abstract.map(b => b.title + ': ' + b.body).join('\\n\\n');\n */\nexport function selectTopBlocks(\n  blocks: NarrativeBlock[],\n  topN: number = 5,\n  context: Parameters<typeof scoreNarrativeBlock>[1],\n  config: WeightingConfig = {}\n): NarrativeBlock[] {\n  const ranked = rankNarrativeBlocks(blocks, context, config);\n  return ranked.slice(0, topN).map((item) => item.block);\n}\n\n/**\n * Generate a weighting report for debugging and analysis.\n * Shows why blocks ranked as they did and which factors contributed most.\n */\nexport function generateWeightingReport(\n  blocks: NarrativeBlock[],\n  context: Parameters<typeof scoreNarrativeBlock>[1],\n  config: WeightingConfig = {}\n): {\n  summary: string;\n  blocks: Array<{\n    title: string;\n    score: number;\n    topContributors: string[];\n  }>;\n} {\n  const ranked = rankNarrativeBlocks(blocks, context, config);\n  \n  const blockReports = ranked.slice(0, 10).map(({ block, score }) => {\n    const contributors = Object.entries(score.breakdown)\n      .filter(([, v]) => v > 0.05) // Only show contributions > 5%\n      .sort(([, a], [, b]) => b - a)\n      .map(\n        ([name, value]) =>\n          `${name}: ${(value * 100).toFixed(0)}%`\n      );\n    \n    return {\n      title: block.title,\n      score: score.totalScore,\n      topContributors: contributors\n    };\n  });\n  \n  const topScore = blockReports[0]?.score ?? 0;\n  const avgScore =\n    blockReports.reduce((sum, item) => sum + item.score, 0) / Math.max(1, blockReports.length);\n  \n  return {\n    summary: `Ranked ${blocks.length} blocks. Top score: ${(topScore * 100).toFixed(1)}%, Average: ${(avgScore * 100).toFixed(1)}%`,\n    blocks: blockReports\n  };\n}\n"